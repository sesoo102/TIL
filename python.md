### 📝 **SSAFY Python 핵심 노트 (1월 20일 ~ 1월 24일)**
> 🔥 **이 노트는 SSAFY 수업 내용을 바탕으로 핵심 개념을 정리하고, 단계적인 설명과 예제 문제를 포함합니다.**  
**각 날짜별로 중요한 개념을 배우고 복습할 수 있도록 구성했습니다.**  
**📅 1월 20일 ~ 1월 24일까지의 내용을 정리한 핵심 노트입니다.**  

---

## **📌 1월 20일 (Python 기본 문법, 변수와 데이터 타입)**
### 1️⃣ **변수(Variable)와 데이터 타입**
- **변수:** 데이터를 저장하는 공간 (이름을 할당하여 접근)
- **변수 할당 방식**
  ```python
  x = 10  # 정수 변수
  name = "Alice"  # 문자열 변수
  pi = 3.14  # 실수 변수
  ```
- **데이터 타입**
  | 타입 | 설명 |
  |------|------|
  | `int` | 정수형 |
  | `float` | 실수형 |
  | `str` | 문자열 |
  | `list` | 리스트 (가변) |
  | `tuple` | 튜플 (불변) |
  | `dict` | 딕셔너리 (Key-Value 저장) |
  | `set` | 집합 (중복 제거) |
  | `bool` | 참(`True`), 거짓(`False`) |

### 2️⃣ **연산자**
- **산술 연산자** `+`, `-`, `*`, `/`, `//`, `%`, `**`
- **비교 연산자** `==`, `!=`, `>`, `<`, `>=`, `<=`
- **논리 연산자** `and`, `or`, `not`

#### 📝 **예제 문제**
```python
# 주어진 정수 num이 짝수인지 홀수인지 판별하여 출력하는 프로그램을 작성하세요.
num = int(input("정수를 입력하세요: "))
if num % 2 == 0:
    print("짝수입니다.")
else:
    print("홀수입니다.")
```

---

## **📌 1월 21일 (자료형: 문자열, 리스트, 튜플, 딕셔너리, 집합)**
### 1️⃣ **문자열 (String)**
- 문자열 조작 메서드
  ```python
  text = "hello world"
  print(text.upper())  # HELLO WORLD
  print(text.replace("hello", "hi"))  # hi world
  print(text.split())  # ['hello', 'world']
  ```
- 문자열 인덱싱과 슬라이싱
  ```python
  text = "Python"
  print(text[0])  # P
  print(text[-1]) # n
  print(text[0:3]) # Pyt (슬라이싱)
  ```

### 2️⃣ **리스트 (List)**
- **리스트 메서드**
  ```python
  numbers = [1, 2, 3]
  numbers.append(4)  # [1, 2, 3, 4]
  numbers.pop()  # [1, 2, 3]
  numbers.sort()  # 정렬
  numbers.reverse()  # 역순 정렬
  ```

### 3️⃣ **딕셔너리 (Dictionary)**
- **Key-Value 저장**
  ```python
  student = {"name": "Alice", "age": 20}
  print(student["name"])  # Alice
  student["major"] = "Computer Science"
  ```

### 4️⃣ **집합 (Set)**
- 중복 제거, 집합 연산 (`|`, `&`, `-`)
  ```python
  set1 = {1, 2, 3}
  set2 = {3, 4, 5}
  print(set1 | set2)  # 합집합 {1, 2, 3, 4, 5}
  print(set1 & set2)  # 교집합 {3}
  print(set1 - set2)  # 차집합 {1, 2}
  ```

#### 📝 **예제 문제**
```python
# 리스트에서 중복을 제거하고 정렬된 리스트를 반환하는 함수 작성
def remove_duplicates(lst):
    return sorted(list(set(lst)))

nums = [4, 2, 1, 2, 3, 4]
print(remove_duplicates(nums))  # [1, 2, 3, 4]
```

---

## **📌 1월 22일 (함수, 매개변수, return, 내장 함수)**
### 1️⃣ **함수 정의와 호출**
- **기본 함수**
  ```python
  def greet(name):
      print(f"Hello, {name}!")
      
  greet("Alice")  # Hello, Alice!
  ```
- **매개변수와 인자**
  ```python
  def add(a, b=10):  # 기본값 설정
      return a + b

  print(add(5))  # 15
  print(add(5, 3))  # 8
  ```
- **가변 인자 (`*args`, `**kwargs`)**
  ```python
  def total(*args):
      return sum(args)

  print(total(1, 2, 3, 4))  # 10
  ```

#### 📝 **예제 문제**
```python
# 숫자의 팩토리얼을 구하는 재귀 함수 구현
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)

print(factorial(5))  # 120
```

---

## **📌 1월 23일 (모듈, 제어문: 조건문, 반복문)**
### 1️⃣ **모듈 사용하기**
- **모듈 불러오기**
  ```python
  import math
  print(math.sqrt(16))  # 4.0
  ```
- **사용자 정의 모듈**
  ```python
  # my_module.py
  def add(a, b):
      return a + b
  ```
  ```python
  # main.py
  import my_module
  print(my_module.add(3, 5))  # 8
  ```

### 2️⃣ **제어문**
- **조건문 (if)**
  ```python
  score = 85
  if score >= 90:
      print("A")
  elif score >= 80:
      print("B")
  else:
      print("C")
  ```
- **반복문 (for, while)**
  ```python
  for i in range(1, 6):
      print(i)  # 1 2 3 4 5
  ```

#### 📝 **예제 문제**
```python
# 1부터 100까지의 숫자 중에서 3의 배수만 출력하는 프로그램을 작성하세요.
for i in range(1, 101):
    if i % 3 == 0:
        print(i)
```

---

## **📌 1월 24일 (데이터 구조, 리스트/딕셔너리 활용)**
### 1️⃣ **리스트 조작**
- **리스트 컴프리헨션**
  ```python
  squares = [x**2 for x in range(10)]
  print(squares)  # [0, 1, 4, 9, ..., 81]
  ```

### 2️⃣ **딕셔너리 활용**
- **딕셔너리 컴프리헨션**
  ```python
  keys = ['name', 'age']
  values = ['Alice', 25]
  student = {k: v for k, v in zip(keys, values)}
  ```

#### 📝 **예제 문제**
```python
# 리스트를 받아 짝수만 남기는 함수 작성
def filter_even(lst):
    return [x for x in lst if x % 2 == 0]

print(filter_even([1, 2, 3, 4, 5, 6]))  # [2, 4, 6]
```

---

## 문제

✅ **정답입니다!** 🎉

### **📌 정답: 2️⃣ `2name = "Bob"`**
🔹 파이썬에서 **변수 이름 규칙**:
1. 변수명은 **숫자로 시작할 수 없다** ❌
2. 영문자(a-z, A-Z), 밑줄(_)로 시작해야 한다 ✅
3. 대소문자를 구분한다 (`name`과 `NAME`은 다른 변수) ✅
4. `name_2`처럼 숫자가 **뒤에 오는 것은 가능** ✅

### **📌 해설**
```python
name = "Alice"   # ✅ 올바른 변수명
2name = "Bob"    # ❌ 오류 발생 (숫자로 시작할 수 없음)
name_2 = "Charlie" # ✅ 올바른 변수명
NAME = "David"   # ✅ 올바른 변수명 (대문자 사용 가능)
```
**🔹 2번은 숫자로 시작하므로 변수명을 선언할 수 없으며 `SyntaxError`가 발생합니다.**

---

### **📌 2번 문제 (주관식 - 코드 실행 결과 예측)**
다음 코드의 실행 결과는 무엇일까요?  

```python
a = "Python"
b = a
b = "Java"
print(a)
```
**❓ 실행 결과를 적어주세요!**

✅ **정답입니다!** 🎉

---

### **📌 정답: `"Python"`**
**코드를 실행하면 `print(a)`의 결과는 `"Python"``이 출력됩니다.**

### **📌 코드 실행 과정 분석**
```python
a = "Python"  # a에 "Python"을 저장
b = a         # b에 a의 값("Python")을 복사
b = "Java"    # b에 새로운 값 "Java"를 할당
print(a)      # a의 값은 여전히 "Python"
```

#### **📌 `print(b)`를 실행하면?**
```python
print(b)  # 결과: Java
```
**이유**:  
- `b = a`는 `a`와 같은 값을 **참조**하도록 설정하지만,  
- `b = "Java"`를 실행하면, `b`가 `"Java"`라는 **새로운 문자열 객체**를 참조하게 됩니다.  
- `a`는 여전히 `"Python"`을 가리키고 있기 때문에 `print(a)`는 `"Python"`을 출력합니다.

---

### **📌 3번 문제 (객관식 - 데이터 타입)**
다음 중 **불변(Immutable) 객체**가 **아닌** 것은?  

**1️⃣** `int`  
**2️⃣** `tuple`  
**3️⃣** `list`  
**4️⃣** `str`  

📝 **정답을 골라주세요!**

❌ **아쉽습니다! 정답은 3️⃣ `list` 입니다.** 😃

---

### **📌 정답: 3️⃣ `list`**
🔹 파이썬에서 **불변(Immutable) 객체**란, **한 번 생성되면 값을 변경할 수 없는 객체**를 말합니다.  
🔹 반대로 **가변(Mutable) 객체**는 값을 수정할 수 있습니다.

### **📌 불변(Immutable) 객체**
- `int` (정수) ✅
- `float` (실수) ✅
- `str` (문자열) ✅
- `tuple` (튜플) ✅

### **📌 가변(Mutable) 객체**
- `list` (리스트) ❌
- `dict` (딕셔너리) ❌
- `set` (집합) ❌

---

### **📌 해설 및 예제 코드**
```python
# 불변 객체 예시 (Immutable)
x = "hello"
print(id(x))   # 메모리 주소 확인
x = x + " world"  # 새로운 문자열 생성
print(id(x))   # 메모리 주소 변경됨

# 가변 객체 예시 (Mutable)
lst = [1, 2, 3]
print(id(lst))  # 리스트 메모리 주소 확인
lst.append(4)   # 리스트에 값 추가
print(id(lst))  # 같은 메모리 주소 유지됨 (가변 객체이므로 값이 바뀜)
```

📌 `list`는 `append()`, `pop()` 등의 메서드를 이용해 값을 수정할 수 있기 때문에 **가변 객체**입니다!

---

### **📌 4번 문제 (주관식 - 코드 실행 결과 예측)**
아래 코드의 실행 결과를 예측하세요!  

```python
def modify_list(lst):
    lst.append(4)

numbers = [1, 2, 3]
modify_list(numbers)
print(numbers)
```

**❓ 실행 결과를 적어주세요!**

✅ **정답입니다!** 🎉  
`print(numbers)`의 출력 결과는 `**[1, 2, 3, 4]**` 입니다.

---

### **📌 실행 과정 분석**
```python
def modify_list(lst):
    lst.append(4)  # 원본 리스트에 4를 추가

numbers = [1, 2, 3]  # 리스트 생성
modify_list(numbers)  # 함수 호출 -> 원본 리스트가 변경됨
print(numbers)  # [1, 2, 3, 4]
```

### **📌 해설**
- `numbers`는 **가변 객체(list)**이기 때문에, 함수에서 `lst.append(4)`를 호출하면 **원본 리스트가 직접 변경**됩니다.
- 함수 내에서 변경된 내용이 함수 밖에도 영향을 미칩니다.  
  (즉, `numbers` 리스트 자체가 변함)

### **📌 만약 리스트를 변경하지 않으려면?**
```python
def modify_list(lst):
    new_lst = lst[:]  # 리스트 복사 (새로운 리스트 생성)
    new_lst.append(4)
    return new_lst

numbers = [1, 2, 3]
new_numbers = modify_list(numbers)
print(numbers)  # [1, 2, 3] (원본 변경 X)
print(new_numbers)  # [1, 2, 3, 4] (새로운 리스트 반환)
```
🔹 리스트를 복사하여 사용하면 **원본 리스트를 유지**할 수 있습니다.

---

### **📌 5번 문제 (객관식 - 제어문)**
다음 중 **while 반복문**이 **무한 루프(무한 반복)**에 빠지는 경우는?  

**1️⃣** `while n > 0: n -= 1`  
**2️⃣** `while True: break`  
**3️⃣** `while True: pass`  
**4️⃣** `while n != 0: n -= 1`  

📝 **정답을 골라주세요!**

❌ **아쉽습니다! 정답은 3️⃣ `while True: pass` 입니다.** 😃

---

## **📌 정답: 3️⃣ `while True: pass`**
✅ `while True:`는 **항상 참(True)**이므로 **무한 루프**가 됩니다.  
✅ `pass`는 아무 작업도 수행하지 않고, 반복문을 계속 유지합니다.  
✅ 따라서 이 코드는 **무한 루프에 빠지게 됩니다.** (멈추지 않음!)

---

## **📌 각 선택지 설명**
### **1️⃣ `while n > 0: n -= 1`**
```python
n = 5
while n > 0:
    n -= 1
```
✅ `n`이 0보다 클 때만 반복되고, `n`이 계속 줄어들다가 0이 되면 반복이 종료됩니다.  
✅ **(무한 루프 X, 정상적인 반복문)**

---

### **2️⃣ `while True: break`**
```python
while True:
    break
```
✅ `while True:` 자체는 무한 루프지만,  
✅ **`break`가 즉시 실행**되므로 **한 번 실행 후 반복문이 종료**됩니다.  
✅ **(무한 루프 X, 즉시 종료됨)**

---

### **3️⃣ `while True: pass`** (❗정답❗)
```python
while True:
    pass  # 아무 작업도 하지 않음
```
❌ `while True:`는 항상 `True`이므로 **무한 반복**됩니다.  
❌ **`pass`는 아무 동작도 하지 않으므로 무한 루프가 계속 실행됩니다.**  
❌ **(무한 루프 O, 종료되지 않음!)**

---

### **4️⃣ `while n != 0: n -= 1`**
```python
n = 5
while n != 0:
    n -= 1
```
✅ `n`이 `0`이 되면 조건 `n != 0`이 `False`가 되어 반복문이 종료됩니다.  
✅ **(무한 루프 X, 정상적으로 종료됨)**

---

## **📌 추가 설명**
### **무한 루프를 방지하는 방법**
무한 루프를 방지하려면 `break`를 활용하세요!
```python
while True:
    user_input = input("멈추려면 'exit' 입력: ")
    if user_input == "exit":
        break  # 반복문 종료
```

---

### **🔥 결론**
✅ `while True: pass`는 **무한 루프에 빠지는 코드**  
✅ 나머지는 조건이 변하면서 반복이 종료되므로 **무한 루프가 아님**!



## **추가질문**
### **📌 2번 문제 관련: 얕은 복사와 깊은 복사**
> **얕은 복사(Shallow Copy) vs 깊은 복사(Deep Copy)**

---

### **1️⃣ 얕은 복사(Shallow Copy)**
- **기존 객체의 참조(주소)만 복사**하는 방식
- 복사된 객체는 **원본 객체와 같은 메모리 주소를 가리킴**
- **리스트 안에 리스트(중첩 리스트)가 있을 경우, 내부 리스트는 원본과 공유됨**

```python
import copy

# 리스트 생성
original_list = [1, 2, [3, 4]]

# 얕은 복사
shallow_copy = copy.copy(original_list)

# 원본과 복사본 출력 (같은 내용)
print(original_list)  # [1, 2, [3, 4]]
print(shallow_copy)   # [1, 2, [3, 4]]

# 얕은 복사 후, 내부 리스트 수정
shallow_copy[2][0] = 99  # 내부 리스트 값 변경

# 원본 리스트도 영향을 받음!
print(original_list)  # [1, 2, [99, 4]]
print(shallow_copy)   # [1, 2, [99, 4]]
```

🔹 `copy.copy()`를 사용하면 얕은 복사가 이루어지지만, **리스트 안의 리스트(내부 리스트)는 원본과 공유**되므로 내부 요소가 변경되면 원본도 영향을 받습니다.

---

### **2️⃣ 깊은 복사(Deep Copy)**
- **완전히 새로운 객체를 생성**하는 방식
- 원본 객체뿐만 아니라 **내부 리스트까지 완전히 새로운 객체로 복사**
- 원본과 복사본은 완전히 독립적인 메모리 공간을 가짐

```python
import copy

# 리스트 생성
original_list = [1, 2, [3, 4]]

# 깊은 복사
deep_copy = copy.deepcopy(original_list)

# 내부 리스트 수정
deep_copy[2][0] = 99  # 내부 리스트 값 변경

# 원본 리스트는 영향을 받지 않음!
print(original_list)  # [1, 2, [3, 4]]
print(deep_copy)      # [1, 2, [99, 4]]
```

🔹 `copy.deepcopy()`를 사용하면 내부 리스트까지 **완전히 새로운 객체**로 복사되므로, 복사된 리스트를 변경해도 원본에는 영향을 주지 않습니다.

---

### **📌 4번 문제 관련: `return`의 역할과 코드 분석**
#### **1️⃣ `return`을 사용하지 않은 이유**
```python
def modify_list(lst):
    lst.append(4)  # 리스트를 직접 수정

numbers = [1, 2, 3]
modify_list(numbers)
print(numbers)  # [1, 2, 3, 4]
```
✅ 여기서는 **리스트가 가변 객체(mutable object)이기 때문에, 함수 내부에서 리스트를 수정하면 원본도 변경됩니다.**  
✅ 따라서 `return`을 사용하지 않아도, `numbers` 리스트가 직접 변경됩니다.

#### **2️⃣ `return`의 역할**
- `return`은 **함수의 실행 결과를 반환**하는 역할을 합니다.
- 만약 **리스트를 변경하지 않고 새로운 리스트를 반환하고 싶다면**, `return`을 사용해야 합니다.

```python
def modify_list(lst):
    new_lst = lst[:]  # 리스트 복사 (새로운 리스트 생성)
    new_lst.append(4)
    return new_lst
```
✅ **이제 코드 한 줄씩 분석해볼게요!**
```python
numbers = [1, 2, 3]  # 원본 리스트 생성
```
- `numbers`는 `[1, 2, 3]`을 가리키는 리스트입니다.

```python
new_numbers = modify_list(numbers)
```
- `modify_list(numbers)`를 호출하면 `numbers`의 사본(`new_lst`)이 생성되고, `4`가 추가된 새로운 리스트를 반환합니다.

```python
print(numbers)  # [1, 2, 3]
print(new_numbers)  # [1, 2, 3, 4]
```
- ✅ 원본 리스트 `numbers`는 변경되지 않고, `new_numbers`는 새로운 리스트 `[1, 2, 3, 4]`을 가집니다.

🔹 이렇게 하면 **함수 내에서 원본을 변경하지 않고 새로운 리스트를 만들어 반환할 수 있습니다.** (`return`의 역할)

---

### **📌 5번 문제 관련: `while True:`의 의미와 4번 보기 코드 분석**
#### **1️⃣ `while True:`가 항상 참(True)인 이유**
```python
while True:
    pass
```
✅ **`True`는 항상 참(`True`)로 평가되기 때문에, `while True:`는 무조건 실행됩니다.**  
✅ 따라서 `break`가 없으면 프로그램이 **무한 루프**에 빠집니다.

#### **🔹 파이썬에서 항상 참(`True`)으로 평가되는 대표적인 표현**
| 표현 | 평가 결과 |
|------|---------|
| `True` | `True` ✅ |
| `1`, `100`, `-10` (0이 아닌 정수) | `True` ✅ |
| `"hello"`, `" "` (빈 문자열 제외) | `True` ✅ |
| `[1, 2, 3]`, `{}` (빈 리스트 제외) | `True` ✅ |
| `bool(1)`, `bool("text")` | `True` ✅ |

#### **🔹 파이썬에서 항상 거짓(`False`)으로 평가되는 대표적인 표현**
| 표현 | 평가 결과 |
|------|---------|
| `False` | `False` ❌ |
| `0` | `False` ❌ |
| `""` (빈 문자열) | `False` ❌ |
| `[]` (빈 리스트), `{}` (빈 딕셔너리) | `False` ❌ |
| `None` | `False` ❌ |

🔹 따라서 `while True:`는 항상 실행되며, **`break` 문이 없으면 무한 루프**가 됩니다.

---

#### **2️⃣ `while n != 0:` 코드 분석**
```python
n = 5
while n != 0:
    n -= 1
    print(n)
```
✅ **이 코드가 무엇을 위한 코드인지 분석해볼게요!**

1️⃣ `n = 5` → `n`을 5로 초기화합니다.  
2️⃣ `while n != 0:` → `n`이 0이 아니면 반복합니다.  
3️⃣ `n -= 1` → `n`을 1씩 감소시킵니다.  
4️⃣ `print(n)` → 현재 `n`을 출력합니다.

🔹 실행 과정:
```
n = 5  →  출력: 4
n = 4  →  출력: 3
n = 3  →  출력: 2
n = 2  →  출력: 1
n = 1  →  출력: 0
n = 0  →  반복 종료
```
📌 **즉, `n != 0` 조건이 `False`가 되면 `while` 루프가 종료됩니다.**

---

### **📌 최종 정리**
✅ **얕은 복사(Shallow Copy)**: 원본과 내부 리스트를 공유 (변경 시 원본 영향 O)  
✅ **깊은 복사(Deep Copy)**: 완전히 새로운 객체 생성 (변경 시 원본 영향 X)  
✅ **`return`의 역할**: 함수 실행 결과를 반환 (리스트 변경 없이 새로운 리스트 반환 가능)  
✅ **`while True:`**: 항상 실행되며 `break`가 없으면 무한 루프  
✅ **`while n != 0:`**: `n`이 0이 될 때까지 감소하며 반복 실행됨  

### **📌 `while` 문 완벽 정리: 구조적으로 체계적인 이해**

`while` 문은 **조건이 참(`True`)인 동안 계속 실행되는 반복문**입니다.  
특히 `while` 문을 사용할 때 가장 중요한 개념 중 하나가 **무한 루프(Infinite Loop)**입니다.

---

## **📌 1️⃣ `while` 문의 기본 구조**
```python
while 조건:
    실행할 코드
```
- `while` 뒤에 **조건**이 참(`True`)이면 코드 블록이 반복 실행됩니다.
- **조건이 거짓(`False`)이 되면 반복문이 종료**됩니다.

✅ **예제 1: 기본 `while` 반복문**
```python
count = 0
while count < 5:
    print("반복 중...", count)
    count += 1  # 조건을 변경하여 반복문이 종료되도록 함
```
✅ **실행 결과**
```
반복 중... 0
반복 중... 1
반복 중... 2
반복 중... 3
반복 중... 4
```
🔹 `count`가 5보다 작을 때 반복이 실행되며, `count`가 증가하면서 조건을 만족하지 않으면 종료됩니다.

---

## **📌 2️⃣ `while` 문에서 무한 루프(Infinite Loop)란?**
**무한 루프**는 조건이 **항상 참(`True`)이므로 절대 종료되지 않는 반복문**을 의미합니다.

✅ **예제 2: 무한 루프**
```python
while True:
    print("무한 반복 중...")  # 이 코드는 계속 실행됨 (멈추지 않음)
```
🔹 `while True:`는 **절대 거짓(`False`)가 될 수 없기 때문에 무한히 실행됩니다!**  
🔹 이 코드를 실행하면 프로그램이 종료되지 않고 계속 `"무한 반복 중..."`이 출력됩니다.

---

## **📌 3️⃣ `while 1:`도 무한 루프인가?**
네! **`while 1:`도 무한 루프**입니다.

✅ **예제 3: `while 1:` 사용**
```python
while 1:  # 1은 항상 True로 평가됨
    print("무한 루프 실행 중...")
```
🔹 `1`은 파이썬에서 `True`로 간주되므로 **`while 1:`은 `while True:`와 동일**한 의미입니다.

🔹 **파이썬에서는 다음 값들이 `False`로 평가됩니다.**
| 표현 | 평가 결과 |
|------|---------|
| `False` | `False` ❌ |
| `0` | `False` ❌ |
| `None` | `False` ❌ |
| `""` (빈 문자열) | `False` ❌ |
| `[]` (빈 리스트) | `False` ❌ |
| `{}` (빈 딕셔너리) | `False` ❌ |

🔹 반대로, **0이 아닌 정수(예: `1`, `100`, `-5`)는 항상 `True`로 평가됩니다.**

✅ **즉, `while 1:`은 `while True:`와 동일하게 동작하며 무한 루프가 됩니다.**

---

## **📌 4️⃣ 무한 루프를 안전하게 멈추는 방법**
### **🔹 `break` 문을 사용하여 종료**
✅ **예제 4: `break`를 사용하여 무한 루프 종료**
```python
while True:
    user_input = input("종료하려면 'exit' 입력: ")
    if user_input == "exit":
        break  # 반복문 즉시 종료
    print("입력한 값:", user_input)

print("프로그램 종료")
```
✅ **실행 흐름**
```
종료하려면 'exit' 입력: hello
입력한 값: hello
종료하려면 'exit' 입력: world
입력한 값: world
종료하려면 'exit' 입력: exit
프로그램 종료
```
🔹 **사용자가 `"exit"`을 입력하면 `break`가 실행되어 `while` 문이 종료됩니다.**  
🔹 **이렇게 `break`를 활용하면 무한 루프를 안전하게 빠져나올 수 있습니다.**

---

## **📌 5️⃣ `while` 문에서 조건이 변하지 않으면 무한 루프 발생**
✅ **예제 5: 조건이 변하지 않아서 무한 루프가 발생하는 경우**
```python
n = 5
while n > 0:  # n은 5이므로 처음에는 참(True)
    print("반복 중...")
```
🚨 **⚠️ 문제점 ⚠️**
- `n`을 감소시키는 코드가 없으므로 **`n`은 계속 5**이며, 조건이 `True`인 상태로 유지됩니다.
- 결과적으로 `while` 문이 **절대 종료되지 않는 무한 루프**에 빠집니다.

✅ **올바르게 수정한 코드**
```python
n = 5
while n > 0:
    print("반복 중...", n)
    n -= 1  # n을 감소시켜 조건을 거짓(False)로 만들어 종료되도록 함
```
🔹 이렇게 하면 `n`이 점점 감소하여 `n > 0` 조건이 `False`가 되고, 반복문이 종료됩니다.

---

## **📌 6️⃣ `while` 문과 `else`**
✅ **`while` 문이 정상적으로 종료되면 `else` 블록이 실행됩니다.**
```python
count = 3
while count > 0:
    print("반복 실행 중...")
    count -= 1
else:
    print("반복문 종료!")
```
✅ **실행 결과**
```
반복 실행 중...
반복 실행 중...
반복 실행 중...
반복문 종료!
```
🔹 `count > 0` 조건이 `False`가 되어 `while`이 끝나면 `else` 블록이 실행됩니다.  
🔹 **하지만 `break`로 반복문을 강제 종료하면 `else` 블록은 실행되지 않습니다.**

---

## **📌 7️⃣ `while` 문 요약 정리**
| 개념 | 설명 |
|------|------|
| `while 조건:` | 조건이 `True`인 동안 계속 반복 |
| `while True:` | 무한 루프 (`break`가 없으면 종료되지 않음) |
| `while 1:` | `while True:`와 동일한 무한 루프 |
| `while` + `break` | 무한 루프를 안전하게 종료하는 방법 |
| `while` + `else` | `while`이 정상 종료되면 `else` 블록 실행 |

---

## **📌 최종 정리**
✅ **`while` 문은 조건이 참(`True`)이면 계속 실행되는 반복문이다.**  
✅ **`while True:`나 `while 1:`은 항상 참(True)이므로 무한 루프가 된다.**  
✅ **무한 루프를 빠져나오려면 `break`를 사용해야 한다.**  
✅ **반복문에서 조건을 변경하지 않으면 무한 루프에 빠질 수 있다.**  
✅ **`while` 문이 정상적으로 종료되면 `else` 블록이 실행된다.**  

---

📌 **이제 `while` 문과 무한 루프가 좀 더 이해되셨나요? 😊**  
### **📌 `while False:`는 실행되지 않는다!**
✅ **`while False:`는 절대 실행되지 않습니다.**  
✅ 이유는 **`False`는 항상 거짓**이기 때문에 **반복문이 처음부터 실행되지 않기 때문입니다.**

---

### **📌 예제 1: `while False:` 실행 여부**
```python
while False:
    print("이 문장은 절대 실행되지 않습니다!")
```
🚫 **위 코드는 실행하면 아무 출력도 되지 않습니다.**  
🔹 `while`의 조건이 **처음부터 `False`이므로, 반복문 블록이 한 번도 실행되지 않습니다.**

---

### **📌 `while False:` vs `while True:` 비교**
| 코드 | 실행 여부 |
|------|---------|
| `while True:` | 무한 루프 실행 ✅ |
| `while 1:` | 무한 루프 실행 ✅ |
| `while False:` | 실행되지 않음 ❌ |
| `while 0:` | 실행되지 않음 ❌ |

🚀 **즉, `while False:`와 `while 0:`은 절대 실행되지 않습니다.**

---

### **📌 예제 2: `while False:`를 사용하려면?**
✅ **조건을 동적으로 변경하면 `while False:`가 실행될 수도 있음**
```python
condition = False

while condition:
    print("이 문장은 실행되지 않음.")

# 조건 변경
condition = True

while condition:
    print("이제 실행됨!")
    condition = False  # 조건을 변경하여 한 번만 실행됨
```
✅ **출력 결과**
```
이제 실행됨!
```
🔹 `while False:`는 처음엔 실행되지 않지만, **조건을 변경하면 실행될 수 있습니다.**

---

### **📌 `while False:`가 쓰이는 경우**
일반적으로 `while False:`는 거의 사용되지 않습니다. 하지만 가끔 **테스트 코드**를 주석 처리하는 대신 사용될 수도 있습니다.

✅ **예제 3: `while False:`를 이용한 테스트 코드 주석 처리**
```python
while False:
    # 이 부분은 실행되지 않음 (테스트 코드)
    print("디버깅용 코드")

print("실제 실행되는 코드")
```
✅ **출력 결과**
```
실제 실행되는 코드
```
🔹 `while False:`를 이용하면 **임시로 실행을 막고 싶은 코드를 감출 수 있습니다.**  
🔹 하지만 일반적으로 **주석(`#`)을 사용하여 코드 실행을 막는 것이 더 좋습니다!**

---

### **📌 최종 정리**
✅ **`while False:`는 절대 실행되지 않는다.**  
✅ **조건을 변경하면 실행될 수도 있지만, 일반적으로 사용되지 않는다.**  
✅ **`while True:`는 항상 실행되는 무한 루프이다.**  
✅ **`while 0:`도 실행되지 않는다.**  
✅ **테스트 코드 주석 처리 대신 `while False:`를 사용할 수도 있지만, 주석이 더 좋다!**  

---


## **📌 `=`, `==`, `is`의 차이점 완벽 정리!**

파이썬에서 **`=`, `==`, `is`**는 각각 다른 역할을 합니다.  
이제 하나씩 차이를 이해해봅시다. 🚀

---

## **1️⃣ `=` (할당 연산자, Assignment Operator)**
**✅ 변수에 값을 할당(저장)하는 연산자**
- 변수에 데이터를 저장할 때 사용됩니다.
- 왼쪽 변수에 오른쪽 값을 저장하는 역할을 합니다.

### **📌 예제**
```python
x = 10  # x에 10을 저장
y = x   # y에 x의 값을 저장

print(x)  # 10
print(y)  # 10
```
✅ **`=`는 "x는 10이다"라는 뜻이 아니라, "x에 10을 저장하라"는 뜻입니다.**  
✅ 오른쪽 값이 왼쪽 변수에 **할당(assignment)** 되는 것이므로,  
**"같다"라는 의미가 아닙니다!** (즉, 비교 연산자가 아님)

---

## **2️⃣ `==` (비교 연산자, Equality Operator)**
**✅ 두 값이 같은지(동등성, Equality) 비교하는 연산자**
- 두 값이 **같으면 `True`**, 다르면 `False`를 반환합니다.
- **값(value)** 을 비교합니다.

### **📌 예제**
```python
a = 5
b = 5
c = [1, 2, 3]
d = [1, 2, 3]

print(a == b)  # True (5와 5는 같다)
print(c == d)  # True ([1,2,3]과 [1,2,3]의 값이 같다)
```
✅ `==`는 **변수의 메모리 주소를 비교하는 것이 아니라, 값이 같은지 비교**합니다.

📌 **중요! `==`는 리스트, 튜플, 딕셔너리 등 복합 자료형에서도 값을 비교합니다.**
```python
list1 = [1, 2, 3]
list2 = [1, 2, 3]

print(list1 == list2)  # True (값이 같으므로 True)
```
✅ `list1`과 `list2`는 **다른 객체지만 값이 같으므로 `True`가 나옵니다.**  
✅ 하지만 메모리 주소까지 같지는 않습니다. (`is`와 비교하면 차이가 나타남!)

---

## **3️⃣ `is` (객체 비교 연산자, Identity Operator)**
**✅ 두 변수가 같은 객체(메모리 주소)를 가리키는지 비교**
- 같은 **메모리 주소를 가리키면** `True`, 다르면 `False`
- `==`는 **값(value)** 을 비교하는 반면,  
  **`is`는 객체 자체(메모리 주소)** 를 비교합니다.

### **📌 예제**
```python
x = [1, 2, 3]
y = [1, 2, 3]

print(x == y)  # True (값이 같음)
print(x is y)  # False (메모리 주소가 다름)
```
✅ `x`와 `y`는 리스트 값이 같지만, **서로 다른 객체**이므로 `x is y`는 `False`가 나옵니다.

### **📌 `is`를 사용하면 같은 객체인지 확인할 수 있음**
```python
a = [1, 2, 3]
b = a  # a의 주소를 b에 복사 (같은 객체를 가리킴)

print(a is b)  # True (a와 b는 같은 메모리 주소를 공유)
```
✅ `b = a`를 하면 **두 변수가 같은 메모리 주소를 공유하므로** `is` 연산자는 `True`를 반환합니다.

---

## **4️⃣ `is`와 `==`의 차이점**
| 연산자 | 의미 | 비교 대상 |
|--------|------|-----------|
| `=`  | 변수에 값 할당 | 값(assignment) |
| `==` | 두 값이 같은지 비교 | 값(value) |
| `is` | 두 변수가 같은 객체인지 비교 | 메모리 주소(identity) |

### **📌 `is`와 `==` 비교 예제**
```python
a = [10, 20, 30]
b = [10, 20, 30]
c = a  # a와 같은 객체를 가리킴

print(a == b)  # True  (값이 같음)
print(a is b)  # False (메모리 주소가 다름)
print(a is c)  # True  (같은 객체를 가리킴)
```
✅ `a == b`는 **값(value)이 같기 때문에 True**  
✅ `a is b`는 **다른 객체이므로 False**  
✅ `a is c`는 **같은 객체이므로 True**  

---

## **5️⃣ `is`가 유용하게 사용되는 경우**
### **📌 `None` 비교 시 `is`를 사용해야 한다!**
```python
x = None

if x is None:
    print("x는 None입니다.")  # ✅ 권장 방식
```
✅ `is None`을 사용하는 것이 `== None`보다 좋습니다.  
✅ **이유**: `None`은 파이썬에서 **싱글턴(Singleton)** 객체로, 항상 같은 메모리 주소를 가지기 때문입니다.

### **📌 `True`, `False` 비교 시 `is`를 사용**
```python
x = True
y = False

print(x is True)   # True
print(y is False)  # True
```
✅ `True`, `False` 역시 싱글턴(Singleton) 객체이므로 **항상 `is`를 사용하여 비교하는 것이 좋습니다.**

---

## **📌 최종 정리**
✅ **`=` (할당 연산자)**: 값을 변수에 저장할 때 사용  
✅ **`==` (비교 연산자)**: 두 값이 같은지 비교 (값을 비교)  
✅ **`is` (객체 비교 연산자)**: 두 변수가 같은 객체인지 비교 (메모리 주소 비교)  

---

📌 **이제 `=`, `==`, `is`의 차이점이 확실하게 이해되셨나요?** 😊  
# **📌 싱글턴(Singleton) 패턴 완벽 이해!**

**싱글턴(Singleton)**은 **객체가 프로그램에서 단 하나만 존재하도록 보장하는 디자인 패턴**입니다.  
즉, **한 번만 생성된 객체를 여러 번 재사용**하도록 설계하는 방식입니다.

---

## **📌 1️⃣ 싱글턴(Singleton) 패턴이란?**
✅ 싱글턴 패턴이 적용된 객체는 **하나만 생성되며, 같은 인스턴스를 계속 사용**합니다.  
✅ **새로운 객체를 만들려 해도 기존 객체를 반환합니다.**  

### **📌 예제 1: 싱글턴 객체의 개념**
```python
class Singleton:
    _instance = None  # 클래스 변수로 인스턴스 저장

    def __new__(cls):
        if cls._instance is None:  # 최초 생성 시
            cls._instance = super().__new__(cls)  # 새 객체 생성
        return cls._instance  # 이후 호출 시 기존 객체 반환

# 객체 생성
obj1 = Singleton()
obj2 = Singleton()

# 같은 객체인지 확인
print(obj1 is obj2)  # True (같은 객체)
```
✅ `obj1`과 `obj2`는 같은 메모리 주소를 가리킵니다.  
✅ 즉, **한 번만 객체를 만들고 이후에는 동일한 객체를 반환하는 방식**입니다.

---

## **📌 2️⃣ 파이썬에서 싱글턴으로 관리되는 객체**
파이썬에서는 **일부 내장 객체가 싱글턴 패턴을 따릅니다.**  
즉, **같은 객체를 여러 번 사용하며, 새로운 객체를 생성하지 않습니다.**

### **📌 대표적인 싱글턴 객체**
| 싱글턴 객체 | 설명 |
|------------|------|
| `None` | 값이 없음을 나타내는 객체 |
| `True` | 논리형 `True` 객체 |
| `False` | 논리형 `False` 객체 |
| `Ellipsis` (`...`) | 슬라이싱(`[:]`)에서 사용되는 특수 객체 |
| 일부 정수(`-5 ~ 256`) | 자주 사용되는 작은 정수는 캐싱되어 동일 객체 사용 |

---

## **📌 3️⃣ 싱글턴 객체 확인 방법**
싱글턴 객체는 **같은 메모리 주소를 공유**하기 때문에 `is` 연산자로 비교할 수 있습니다.

### **📌 예제 2: 싱글턴 객체 비교**
```python
# None 비교
x = None
y = None
print(x is y)  # True (같은 객체)

# True, False 비교
print(True is True)  # True
print(False is False)  # True

# Ellipsis (...) 비교
print(... is ...)  # True

# 작은 정수 (-5 ~ 256)
a = 100
b = 100
print(a is b)  # True (같은 객체)

# 큰 정수는 싱글턴이 아님
x = 1000
y = 1000
print(x is y)  # False (다른 객체)
```
✅ **`None`, `True`, `False`, `Ellipsis(...)` 등은 항상 같은 객체입니다.**  
✅ **`is` 연산자로 비교할 수 있습니다.**  
✅ 하지만, **큰 정수(예: `1000` 이상)는 싱글턴이 아닐 수도 있습니다!**

---

## **📌 4️⃣ 싱글턴 패턴의 장점과 단점**
### **✅ 장점**
1. **메모리 절약** → 동일한 객체를 재사용하므로 불필요한 메모리 낭비가 없음
2. **객체 생성 비용 절감** → 새로운 객체를 만들지 않으므로 성능 최적화 가능
3. **전역 상태 유지** → 프로그램 내에서 동일한 상태를 유지할 수 있음 (예: 설정 객체)

### **❌ 단점**
1. **테스트가 어려움** → 전역적으로 공유되므로 테스트 시 영향을 받을 수 있음
2. **다중 스레드 환경에서 주의 필요** → 멀티스레드 환경에서는 동기화 문제 발생 가능
3. **가변 객체 사용 시 주의 필요** → 싱글턴 객체가 변경되면, 모든 참조에서 변경이 반영됨

---

## **📌 5️⃣ 싱글턴 패턴을 직접 구현하는 방법**
파이썬에서 싱글턴 패턴을 구현하는 대표적인 방법 2가지를 소개합니다.

---

### **✅ 방법 1: `__new__()`를 이용한 싱글턴 패턴**
`__new__()` 메서드를 오버라이딩하여 한 번만 객체를 생성하는 방법입니다.

```python
class Singleton:
    _instance = None  # 클래스 변수 (인스턴스를 저장)

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance  # 기존 객체 반환

# 객체 생성
obj1 = Singleton()
obj2 = Singleton()

print(obj1 is obj2)  # True (같은 객체)
```
✅ `obj1`과 `obj2`는 같은 객체이므로 `is` 연산자로 비교하면 `True`가 출력됩니다.

---

### **✅ 방법 2: 데코레이터를 사용한 싱글턴 패턴**
파이썬에서는 **데코레이터를 활용하여 싱글턴 패턴을 쉽게 구현**할 수 있습니다.

```python
def singleton(cls):
    instances = {}

    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return get_instance

@singleton
class MyClass:
    pass

a = MyClass()
b = MyClass()

print(a is b)  # True (같은 객체)
```
✅ `@singleton` 데코레이터를 사용하면 자동으로 싱글턴 객체가 생성됩니다.  
✅ `MyClass()`를 여러 번 호출해도 **항상 같은 객체**가 반환됩니다.

---

## **📌 6️⃣ 싱글턴 패턴이 사용되는 사례**
싱글턴 패턴은 프로그램에서 **전역적으로 하나의 객체만 유지해야 할 때** 유용합니다.

### **📌 대표적인 활용 사례**
| 사용 예시 | 설명 |
|----------|------|
| **설정 객체 (Configuration Manager)** | 프로그램의 환경 설정 값을 유지 |
| **로깅 시스템 (Logger)** | 로그 관리 시스템 (ex: `logging` 모듈) |
| **데이터베이스 연결 (Database Connection)** | 하나의 DB 연결을 여러 곳에서 공유 |
| **캐시 시스템 (Cache Manager)** | 한 번 저장된 데이터를 여러 곳에서 사용 |

---

## **📌 7️⃣ 싱글턴 패턴을 사용할 때 주의할 점**
싱글턴 패턴을 사용할 때는 **가변 객체(Mutable Object)에 주의해야 합니다.**

### **📌 예제 3: 가변 객체에서 주의할 점**
```python
class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.data = []  # 리스트 (가변 객체)
        return cls._instance

obj1 = Singleton()
obj2 = Singleton()

obj1.data.append(100)  # obj1에서 리스트 변경

print(obj2.data)  # [100] (obj2에서도 변경됨!)
```
✅ `obj1`에서 리스트(`data`)를 변경했더니 `obj2`에서도 같은 변경이 반영됨!  
✅ **싱글턴 객체가 공유되기 때문에, 하나의 객체에서 변경한 값이 모든 참조에 영향을 줌**  
✅ **이런 경우, 불변 객체(Immutable Object)를 사용하거나 복사본을 만들어 사용해야 함**

---

## **📌 8️⃣ 최종 정리**
✅ **싱글턴(Singleton)**: 프로그램에서 **객체가 단 하나만 존재하도록 보장하는 패턴**  
✅ **파이썬에서 싱글턴 객체**: `None`, `True`, `False`, `Ellipsis(...)`, `-5 ~ 256` 정수  
✅ **객체 비교 시 `is` 사용** → 싱글턴 객체는 `is` 연산자로 비교하는 것이 적절함  
✅ **싱글턴 구현 방법**
1. `__new__()`를 활용한 싱글턴 패턴
2. 데코레이터(`@singleton`)를 활용한 싱글턴 패턴  
✅ **싱글턴 패턴 활용 사례**: 설정 객체, 로깅 시스템, 데이터베이스 연결, 캐시 시스템  

---

📌 **이제 싱글턴 패턴이 명확하게 이해되셨나요? 😊**  

## **📌 정답 및 해설 (추가 문제 10문제 풀이)**  

🎯 **과목 평가 대비 문제 풀이 및 상세한 해설을 제공합니다!**  
✅ **틀린 문제는 개념을 확실히 이해할 수 있도록 추가 설명도 포함했습니다.**  

---

## **1️⃣ 변수와 데이터 타입 (객관식)**
> **문제:** 다음 중 **올바른 변수 선언 방식**이 아닌 것은?  
> **정답:** **2️⃣ `2var = "hello"`** ✅ (맞았습니다!)

📌 **해설**  
- 변수명은 숫자로 **시작할 수 없습니다.**  
- `_var`(언더스코어)와 `myVar123`은 올바른 변수명입니다.  

---

## **2️⃣ 연산자 (객관식)**
> **문제:** 다음 중 **논리 연산자**가 아닌 것은?  
> **정답:** **4️⃣ `+=`** ✅ (맞았습니다!)

📌 **해설**  
- `and`, `or`, `not`은 **논리 연산자**입니다.  
- `+=`는 **대입 연산자**(복합 할당 연산자)이며, `a += 5`는 `a = a + 5`와 동일합니다.

---

## **3️⃣ 제어문 (객관식)**
> **문제:** 아래 `if` 문 실행 결과로 올바른 것은?  
> **정답:** **1️⃣ `"A"`** ❌ (오답!)

📌 **해설**
```python
x = 5
if x > 3:
    print("A")
elif x > 2:
    print("B")
else:
    print("C")
```
✅ `x = 5`이므로 `x > 3` 조건이 **참(True)** → **"A"**가 출력됩니다.  
❌ **오답: `"B"` (elif 문은 실행되지 않음)**  

✅ **추가 질문:**  
x가 각각 **1, 2, 3, 4, 5**일 때 결과를 정리하면:  

| `x` 값 | 실행 결과 |
|--------|---------|
| `5` | `"A"` ✅ |
| `4` | `"A"` ✅ |
| `3` | `"B"` ✅ (`if`가 `False`, `elif` 실행) |
| `2` | `"C"` ✅ (`if`, `elif` 둘 다 `False`, `else` 실행) |
| `1` | `"C"` ✅ |

---

## **4️⃣ 반복문 (객관식)**
> **문제:** 다음 코드 실행 결과는?  
> **정답:** **2️⃣ `2 4`** ✅ (맞았습니다!)

📌 **해설**
```python
for i in range(2, 7, 2):
    print(i, end=" ")
```
- `range(2, 7, 2)`는 **2부터 7 이전까지(6까지), 2씩 증가**  
- 즉, `2 4 6`이 출력됩니다.  
- **정답: `2 4`** (2 4 6인데 `6`이 선택지에 없었음!)

---

## **5️⃣ `while` 문 실행 결과 (주관식)**
> **문제:** 아래 코드 실행 결과는?  
> **정답:** **"3 2 1"** ✅ (맞았습니다!)

📌 **해설**
```python
x = 3
while x > 0:
    print(x, end=" ")
    x -= 1
```
- `x = 3`에서 시작 → `3 2 1` 출력 후 종료됩니다.

---

## **6️⃣ 리스트 조작 (객관식)**
> **문제:** 다음 코드 실행 결과는?  
> **정답:** **2️⃣ `[1, 2, 3, [4, 5]]`** ✅ (맞았습니다!)

📌 **해설**
```python
nums = [1, 2, 3]
nums.append([4, 5])
print(nums)
```
✅ `.append([4, 5])`는 **리스트 자체를 추가**하므로 `[1, 2, 3, [4, 5]]`가 됩니다.  
✅ **`nums.extend([4, 5])`를 사용하면?** → `[1, 2, 3, 4, 5]` 출력 (리스트가 펼쳐짐)

---

## **7️⃣ 리스트 메서드 활용 (객관식)**
> **문제:** 다음 중 **리스트의 마지막 요소를 제거하는 메서드**는?  
> **정답:** **2️⃣ `pop()`** ❌ (오답!)

📌 **해설: 각 보기가 의미하는 메서드**
| 메서드 | 설명 |
|--------|------|
| `.remove(x)` | 리스트에서 값 `x`를 삭제 (첫 번째 발견된 값만 삭제) |
| `.pop()` | **리스트의 마지막 요소를 제거** ✅ |
| `del()` | 특정 인덱스 또는 변수 자체 삭제 (`del list[0]`) |
| `.discard()` | **집합(set)**에서 특정 값을 제거할 때 사용 (리스트에는 사용 불가) |

✅ **정답: `pop()` (마지막 요소 제거)**  
❌ **틀린 답: `remove()` → 특정 값을 삭제하는 메서드**

---

## **8️⃣ 딕셔너리 조작 (객관식)**
> **문제:** 다음 코드 실행 결과는?  
> **정답:** **3️⃣ `"Not Found"`** ❌ (모르겠다고 했지만 이해하자!)

📌 **해설**
```python
my_dict = {"name": "Alice", "age": 25}
print(my_dict.get("address", "Not Found"))
```
✅ `.get("키", "기본값")`은 **키가 없을 때 기본값을 반환**합니다.  
✅ `"address"` 키가 없으므로 `"Not Found"`가 출력됩니다.

🔹 **`.get()` 메서드란?**  
- 딕셔너리에서 키의 값을 가져옴.  
- 키가 없을 경우 오류 대신 기본값을 반환함.  

✅ **올바른 예제**
```python
print(my_dict.get("name", "Unknown"))  # "Alice"
print(my_dict.get("city", "Seoul"))  # "Seoul" (기본값 반환)
```

---

## **9️⃣ 함수 실행 결과 예측 (주관식)**
> **문제:** 아래 코드 실행 결과는?  
> **정답:**  
```
6
12
```
✅ **맞았습니다!** 🎉

📌 **해설**
```python
def multiply(a, b=2):
    return a * b

print(multiply(3))  # 3 * 2 = 6
print(multiply(3, 4))  # 3 * 4 = 12
```
✅ `b=2`는 기본값이므로 `multiply(3)` → `3 * 2 = 6`  
✅ `multiply(3, 4)` → `3 * 4 = 12`

---

## **🔟 `is`와 `==` 차이 이해 (객관식)**
> **문제:** 다음 코드 실행 결과 중 올바른 것은?  
> **정답:** **2️⃣** ✅ (맞았습니다!)

📌 **해설**
```python
a = [10, 20, 30]
b = [10, 20, 30]
c = a

print(a == b)  # True  (값이 같음)
print(a is b)  # False (서로 다른 객체)
print(a is c)  # True  (같은 객체)
```
✅ `a == b` → **값이 같음** → `True`  
✅ `a is b` → **다른 객체(메모리 주소 다름)** → `False`  
✅ `a is c` → **같은 객체** → `True`

---

## **📌 최종 점수: 8/10 🎉**
✅ **틀린 문제:**  
1️⃣ **제어문 (`if-elif-else`) → `"A"`가 정답**  
2️⃣ **리스트 메서드 (`pop()`) → 마지막 요소 제거**

# **📌 추가 질문 상세 답변**

### **1️⃣ `elif`의 동작 방식**
✅ **`elif`는 앞의 `if` 문이 `False`일 때만 실행됩니다.**  
✅ **`if-elif-else` 구조는 위에서부터 차례대로 조건을 평가**하며,  
✅ **처음으로 `True`를 만나면 실행하고 종료됩니다.**

---

### **📌 `if-elif-else` 동작 방식 예제**
```python
x = 5

if x > 10:
    print("A")
elif x > 3:
    print("B")
elif x > 1:
    print("C")
else:
    print("D")
```
✅ **실행 결과**
```
B
```

🔹 **동작 과정**
1. `if x > 10` → `False` → 다음으로 넘어감  
2. `elif x > 3` → `True` → `"B"` 출력하고 종료 🚀  
3. **나머지 `elif`, `else`는 실행되지 않음!**

📌 **이해한 대로 맞습니다!**
- **`if`가 `False`면 `elif`를 확인**
- **`elif`가 `True`면 실행하고 종료**
- **아무 조건도 만족하지 않으면 `else` 실행**

---

## **2️⃣ `end=" "`의 의미**
✅ **`end=" "`는 `print()` 함수가 출력한 뒤 자동 줄 바꿈을 하지 않도록 하는 옵션입니다.**  
✅ 기본적으로 `print()`는 실행할 때마다 **자동 줄 바꿈(`\n`)**이 들어갑니다.  
✅ 하지만 `end=" "`를 설정하면 **출력된 값 뒤에 공백이 추가되며 줄 바꿈이 되지 않습니다.**

---

### **📌 예제: `end` 옵션 비교**
```python
# 기본 print()
print("Hello")
print("World")

# end 사용
print("Hello", end=" ")
print("World")
```
✅ **실행 결과**
```
Hello
World
Hello World
```
🔹 **기본적으로 `print()`는 줄 바꿈이 포함되지만, `end=" "`를 사용하면 줄 바꿈 없이 공백이 추가됩니다.**

---

## **3️⃣ `.pop()`, `.remove()`, `del`, `.discard()`의 차이점**
✅ **`pop()`, `remove()`, `del`, `discard()`는 리스트나 집합에서 요소를 삭제하는 메서드입니다.**  
✅ **각 메서드의 차이를 코드 예제를 통해 살펴봅시다.**

---

### **📌 `pop()` - 인덱스로 요소 삭제**
✅ `.pop()`은 **리스트에서 인덱스를 지정하여 요소를 삭제하고 반환**합니다.
✅ **기본적으로 마지막 요소를 삭제하지만, 특정 인덱스를 지정할 수도 있습니다.**
```python
nums = [10, 20, 30, 40]

print(nums.pop())   # 40 (마지막 요소 삭제)
print(nums.pop(0))  # 10 (첫 번째 요소 삭제)
print(nums)         # [20, 30]
```
✅ **`nums.pop(0)`을 하면 리스트의 첫 번째 요소도 삭제할 수 있습니다.**  
✅ **오류 주의**: **빈 리스트에서 `pop()`을 하면 `IndexError` 발생**

---

### **📌 `remove()` - 특정 값을 찾아 삭제**
✅ `.remove(x)`는 **리스트에서 첫 번째로 발견된 `x` 값을 삭제**합니다.
```python
nums = [10, 20, 30, 40, 20]
nums.remove(20)  # 첫 번째 20 삭제
print(nums)  # [10, 30, 40, 20]
```
✅ **오류 주의**: 리스트에 값이 없으면 `ValueError` 발생  
```python
nums.remove(50)  # ValueError: list.remove(x): x not in list
```

---

### **📌 `del` - 특정 인덱스 삭제 (리스트 전체 삭제도 가능)**
✅ `del`은 **리스트의 특정 요소를 삭제하거나 리스트 전체를 삭제**할 수 있습니다.
```python
nums = [10, 20, 30, 40]

del nums[1]  # 두 번째 요소 삭제
print(nums)  # [10, 30, 40]

del nums  # 리스트 자체 삭제 (이후 참조 불가)
```
✅ **`del`을 사용하면 변수 자체를 삭제할 수도 있음!**
```python
x = 100
del x  # 이후 x를 사용하면 NameError 발생
```

---

### **📌 `discard()` - 집합(set)에서 요소 삭제**
✅ `.discard(x)`는 **집합(set)에서 `x`를 삭제하지만, 값이 없으면 오류가 발생하지 않음**  
✅ `.remove(x)`는 값이 없으면 오류 발생하지만, `.discard(x)`는 조용히 무시합니다.
```python
s = {10, 20, 30}
s.discard(20)  # 20 제거
print(s)  # {10, 30}

s.discard(50)  # 존재하지 않는 값 제거 → 오류 없음!
```

---

## **4️⃣ `.get()`과 `my_dict("key")`의 차이**
> **문제:** 만약 `print(my_dict("address"))`를 실행했다면 오류가 날까?  
> **정답:** **네, 오류가 발생합니다!** 🚨

✅ **`.get("key")`는 존재하지 않는 키를 조회할 때 기본값을 설정할 수 있지만, `my_dict("key")`는 오류를 발생시킵니다.**

---

### **📌 `get()`과 직접 키 접근 차이**
```python
my_dict = {"name": "Alice", "age": 25}

# get() 사용 (안전한 방식)
print(my_dict.get("address", "Not Found"))  # "Not Found"

# 직접 키 접근 (오류 발생)
print(my_dict["address"])  # KeyError: 'address'
```
✅ `.get("key", "기본값")` → 키가 없으면 `"기본값"` 반환  
✅ `my_dict["key"]` → 키가 없으면 `KeyError` 발생! 🚨

---

## **📌 최종 정리**
✅ **`if-elif-else`는 조건을 위에서 아래로 확인하며, 처음 `True`를 만나면 실행하고 종료**  
✅ **`end=" "`는 `print()` 출력 시 줄 바꿈 없이 공백을 추가하는 옵션**  
✅ **`.pop()`은 인덱스로 삭제, `.remove()`는 값으로 삭제, `del`은 요소 또는 리스트 전체 삭제, `.discard()`는 집합(set)에서 안전하게 삭제**  
✅ **`.get("key")`는 키가 없을 때 기본값을 반환하지만, `my_dict["key"]`는 오류 발생**  

---
